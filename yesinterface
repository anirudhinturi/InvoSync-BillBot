import os
import re
import cv2
import pytesseract
import pandas as pd
import numpy as np
from pytesseract import Output
from pdf2image import convert_from_path
import tkinter as tk
from tkinter import ttk, filedialog, messagebox
from PIL import Image, ImageTk
from datetime import datetime
import sys
import subprocess


# --- CORE EXTRACTION LOGIC (from our previous script) ---
# This is the "engine" of our application.

def find_value_nearby(ocr_df, label_keywords, max_words=3, max_distance=400):
    """
    Finds a value for a given list of keywords by looking for text
    on the same visual line to the right, but within a limited distance.
    """
    try:
        pattern = '|'.join(label_keywords)
        keyword_df = ocr_df[ocr_df['text'].str.lower().str.contains(pattern, na=False, regex=True)]
        if keyword_df.empty:
            return None

        keyword_row = keyword_df.iloc[0]
        keyword_y = keyword_row['top'] + keyword_row['height'] / 2
        keyword_x_end = keyword_row['left'] + keyword_row['width']

        line_df = ocr_df[abs(ocr_df['top'] + ocr_df['height'] / 2 - keyword_y) < 15]
        value_df = line_df[
            (line_df['left'] > keyword_x_end) & (line_df['left'] < keyword_x_end + max_distance)].sort_values('left')

        if not value_df.empty:
            return ' '.join(value_df.head(max_words)['text']).replace(':', '').strip()
    except Exception:
        pass
    return None


def find_buyer(ocr_df, company_hints=['ltd', 'limited', 'electronics']):
    """
    Intelligently finds the Buyer by first locating a label like 'Buyer' or 'Bill to',
    then searching the area below for a company name containing a hint.
    """
    try:
        label_keywords = ['buyer', 'bill to']
        pattern = '|'.join(label_keywords)
        label_df = ocr_df[ocr_df['text'].str.lower().str.contains(pattern, na=False, regex=True)]
        if label_df.empty:
            return None

        label_row = label_df.iloc[0]
        search_top = label_row['top'] + label_row['height']
        search_area_df = ocr_df[(ocr_df['top'] > search_top) & (ocr_df['top'] < search_top + 100)]

        company_pattern = '|'.join(company_hints)
        company_df = search_area_df[
            search_area_df['text'].str.lower().str.contains(company_pattern, na=False, regex=True)]

        if not company_df.empty:
            company_row = company_df.iloc[0]
            company_line_num = company_row['line_num']
            full_company_line_df = ocr_df[ocr_df['line_num'] == company_line_num]
            return ' '.join(full_company_line_df['text'])
    except Exception:
        pass
    return None


def extract_table(ocr_df):
    """
    A precise table extraction logic that maps words to columns based on the
    exact horizontal position of the headers.
    """
    items = []
    try:
        header_map = {
            'S.No': ['s.no'], 'Description of Services': ['description'],
            'Quantity': ['quantity', 'qty'], 'Rate': ['rate'], 'Total Amount': ['amount']
        }
        all_header_keywords = [item for sublist in header_map.values() for item in sublist]
        header_candidates = ocr_df[ocr_df['text'].str.lower().isin(all_header_keywords)]
        if header_candidates.empty: return []

        header_line_num = header_candidates['line_num'].mode()[0]
        header_df = ocr_df[ocr_df['line_num'] == header_line_num]

        column_boundaries = {}
        sorted_headers = []
        for col_name, keywords in header_map.items():
            matches = header_df[header_df['text'].str.lower().str.contains('|'.join(keywords))]
            if not matches.empty:
                header_pos = matches.iloc[0]
                column_boundaries[col_name] = {'start': header_pos['left']}
                sorted_headers.append((header_pos['left'], col_name))

        sorted_headers.sort()
        for i in range(len(sorted_headers)):
            _, current_col = sorted_headers[i]
            if i + 1 < len(sorted_headers):
                next_x, _ = sorted_headers[i + 1]
                column_boundaries[current_col]['end'] = next_x - 5
            else:
                column_boundaries[current_col]['end'] = ocr_df['left'].max() + 100

        footer_keywords = ['total', 'sub-total', 'subtotal']
        footer_candidates = ocr_df[ocr_df['text'].str.lower().isin(footer_keywords)]

        table_start_y = header_df['top'].mean()
        table_end_y = footer_candidates.iloc[0]['top'] if not footer_candidates.empty else ocr_df['top'].max()

        table_content_df = ocr_df[(ocr_df['top'] > table_start_y) & (ocr_df['top'] < table_end_y)]

        for line_num in sorted(table_content_df['line_num'].unique()):
            line_df = table_content_df[table_content_df['line_num'] == line_num]
            if line_df.empty or len(line_df) < 2: continue

            row_data = {col: [] for col in header_map.keys()}
            for _, word_data in line_df.iterrows():
                word_x_center = word_data['left'] + word_data['width'] / 2
                for col_name, bounds in column_boundaries.items():
                    if 'start' in bounds and 'end' in bounds and bounds['start'] <= word_x_center < bounds['end']:
                        row_data[col_name].append(word_data['text'])
                        break

            final_row = {col_name: ' '.join(words) for col_name, words in row_data.items()}
            if final_row.get('Description of Services') or final_row.get('S.No'):
                items.append(final_row)

    except Exception as e:
        messagebox.showerror("Table Parsing Error", f"Could not parse table details: {e}")
    return items


def process_file(file_path):
    """Main function to orchestrate the extraction and return DataFrames."""
    try:
        file_extension = os.path.splitext(file_path)[1].lower()
        if file_extension == '.pdf':
            images = convert_from_path(file_path, poppler_path=r"C:\poppler-25.07.0\Library\bin")
            img = np.array(images[0])
            img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)
        else:
            img = cv2.imread(file_path)
            if img is None: raise FileNotFoundError

        config = '--psm 6'
        ocr_data = pytesseract.image_to_data(img, config=config, output_type=Output.DICT)
        ocr_df = pd.DataFrame(ocr_data)
        ocr_df.dropna(subset=['text'], inplace=True)
        ocr_df = ocr_df[ocr_df['conf'].astype(float) > 40]
        ocr_df['text'] = ocr_df['text'].str.strip()
        ocr_df = ocr_df[ocr_df['text'] != '']
        ocr_df.reset_index(drop=True, inplace=True)

        invoice_no = find_value_nearby(ocr_df, ['invoice no'])
        if not invoice_no:
            invoice_pattern = r'\w+/\w+/\d+/\d+'
            invoice_matches = ocr_df[ocr_df['text'].str.match(invoice_pattern, case=False)]
            if not invoice_matches.empty:
                invoice_no = invoice_matches.iloc[0]['text']

        buyer = find_buyer(ocr_df)
        invoice_date = find_value_nearby(ocr_df, ['invoice date', 'ack date', 'date'])
        gstin = find_value_nearby(ocr_df, ['gstin/uin', 'gstin'])

        line_items = extract_table(ocr_df)

        summary_data = {
            'Invoice No': [invoice_no or 'Not Found'], 'Invoice Date': [invoice_date or 'Not Found'],
            'Buyer': [buyer or 'Not Found'], 'GSTIN': [gstin or 'Not Found'],
            'Line Items Count': [len(line_items)]
        }
        summary_df = pd.DataFrame(summary_data)

        details_df = pd.DataFrame()
        if line_items:
            details_df = pd.DataFrame(line_items,
                                      columns=['S.No', 'Description of Services', 'Quantity', 'Rate', 'Total Amount'])

        return summary_df, details_df

    except Exception as e:
        messagebox.showerror("Processing Error", f"An error occurred: {e}")
        return pd.DataFrame(), pd.DataFrame()


# --- TKINTER DESKTOP APPLICATION ---

class InvoiceApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Smart Invoice")
        self.root.geometry("950x600")
        self.root.configure(bg="#FFFFFF")

        self.summary_df = pd.DataFrame()
        self.details_df = pd.DataFrame()

        # --- Style Configuration ---
        style = ttk.Style(self.root)
        style.theme_use("clam")
        style.configure("TNotebook.Tab", font=("Segoe UI", 10, "bold"), padding=[10, 5], foreground="#555555")
        style.configure("Treeview.Heading", font=("Segoe UI", 10, "bold"))
        style.configure("Treeview", rowheight=25, font=("Segoe UI", 9))
        style.configure("TButton", font=("Segoe UI", 10, "bold"), foreground="white", background="#2B54A5",
                        borderwidth=0)
        style.map("TButton", background=[('active', '#3C78D8')])

        # --- Header ---
        header_frame = tk.Frame(self.root, bg="#FFFFFF")
        header_frame.pack(fill=tk.X, padx=20, pady=10)

        if os.path.exists('log.jpg'):
            logo_img = Image.open('log.jpg')
            logo_img.thumbnail((120, 120))
            self.logo = ImageTk.PhotoImage(logo_img)
            ttk.Label(header_frame, image=self.logo, background="#FFFFFF").pack(side=tk.LEFT, padx=10)

        title_frame = tk.Frame(header_frame, bg="#FFFFFF")
        title_frame.pack(side=tk.LEFT, anchor="w")
        ttk.Label(title_frame, text="Smart Invoice", font=("Segoe UI", 24, "bold"), foreground="#2B54A5",
                  background="#FFFFFF").pack(anchor="w")
        ttk.Label(title_frame, text="Automated Invoice Data Extraction", font=("Segoe UI", 10), foreground="#555555",
                  background="#FFFFFF").pack(anchor="w")

        # --- Main Content Area ---
        content_frame = tk.Frame(self.root, bg="#F0F0F0", bd=1, relief="solid", borderwidth=1,
                                 highlightbackground="#DDDDDD")
        content_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        # --- Tabs ---
        self.notebook = ttk.Notebook(content_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Tab 1: Upload & Process
        upload_tab = ttk.Frame(self.notebook)
        self.notebook.add(upload_tab, text="Upload & Process")

        upload_button = ttk.Button(upload_tab, text="Select and Process Invoice File", command=self.upload_and_process,
                                   style="TButton")
        upload_button.pack(expand=True)

        # Tab 2: Invoice Summary
        self.summary_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.summary_tab, text="Invoice Summary")
        self.create_summary_view()

        # Tab 3: Service Details
        self.details_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.details_tab, text="Service Details")
        self.create_details_view()

        # --- Footer ---
        footer_frame = tk.Frame(self.root, bg="#FFFFFF")
        footer_frame.pack(fill=tk.X, padx=20, pady=5)
        ttk.Button(footer_frame, text="Export to Excel", command=self.export_to_excel).pack(side=tk.RIGHT)

    def create_summary_view(self):
        cols = ('Invoice No', 'Invoice Date', 'Buyer', 'GSTIN', 'Line Items Count')
        self.summary_tree = self.create_treeview(self.summary_tab, cols)

    def create_details_view(self):
        cols = ('S.No', 'Description of Services', 'Quantity', 'Rate', 'Total Amount')
        self.details_tree = self.create_treeview(self.details_tab, cols)

    def create_treeview(self, parent, columns):
        frame = ttk.Frame(parent)
        frame.pack(fill=tk.BOTH, expand=True)
        tree = ttk.Treeview(frame, columns=columns, show='headings')
        for col in columns:
            tree.heading(col, text=col)
            tree.column(col, width=150, anchor='w')

        vsb = ttk.Scrollbar(frame, orient="vertical", command=tree.yview)
        vsb.pack(side='right', fill='y')
        tree.configure(yscrollcommand=vsb.set)

        tree.pack(fill=tk.BOTH, expand=True)
        return tree

    def populate_treeview(self, tree, df):
        # Clear existing data
        for i in tree.get_children():
            tree.delete(i)
        # Insert new data
        for _, row in df.iterrows():
            tree.insert("", "end", values=list(row))

    def upload_and_process(self):
        file_path = filedialog.askopenfilename(
            title="Select an Invoice File",
            filetypes=(("PDF files", "*.pdf"), ("Image files", "*.jpg *.jpeg *.png"), ("All files", "*.*"))
        )
        if not file_path:
            return

        self.root.update_idletasks()  # Update GUI to show changes
        messagebox.showinfo("Processing", "Processing invoice... This may take a moment.")

        self.summary_df, self.details_df = process_file(file_path)

        if not self.summary_df.empty:
            self.populate_treeview(self.summary_tree, self.summary_df)
            if not self.details_df.empty:
                self.populate_treeview(self.details_tree, self.details_df)

            messagebox.showinfo("Success", "Invoice processed successfully!")
            self.notebook.select(self.summary_tab)  # Switch to summary tab
        else:
            messagebox.showerror("Error", "Could not extract any data from the selected file.")

    def export_to_excel(self):
        if self.summary_df.empty and self.details_df.empty:
            messagebox.showwarning("No Data", "There is no data to export. Please process an invoice first.")
            return

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_filename = f"Formatted_Invoice_Output_{timestamp}.xlsx"

        try:
            with pd.ExcelWriter(output_filename, engine='openpyxl') as writer:
                self.summary_df.to_excel(writer, sheet_name='Invoice Summary', index=False)
                if not self.details_df.empty:
                    self.details_df.to_excel(writer, sheet_name='Service Details', index=False)

            messagebox.showinfo("Export Successful", f"Data saved to {output_filename}")

            # Automatically open the file
            if sys.platform == "win32":
                os.startfile(output_filename)
            elif sys.platform == "darwin":
                subprocess.call(["open", output_filename])
            else:
                subprocess.call(["xdg-open", output_filename])

        except Exception as e:
            messagebox.showerror("Export Error", f"Could not save or open the file. Error: {e}")


if __name__ == "__main__":
    root = tk.Tk()
    app = InvoiceApp(root)
    root.mainloop()
